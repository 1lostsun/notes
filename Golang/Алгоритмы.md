**Пузырьковая сортировка (Bubble Sort)**  

Перебираем массив много раз, сравниваем соседние элементы и меняем их местами, если они в неправильном порядке.  

Сложность: `O(n^2)`. Подходит только для учебных примеров.

```go
package main

// BubbleSort — сортировка пузырьком
func BubbleSort(arr []int) {
	n := len(arr)
	for i := 0; i < n-1; i++ {
		for j := 0; j < n-i-1; j++ {
			if arr[j] > arr[j+1] {
				arr[j], arr[j+1] = arr[j+1], arr[j]
			}
		}
	}
}

```

---
**Сортировка вставками (Insertion Sort)**  

Берём элемент и вставляем его на правильное место в уже отсортированной части массива.  

Сложность: `O(n^2)`. Хорошо работает на почти отсортированных данных.

```go
package main

// InsertionSort — сортировка вставками
func InsertionSort(arr []int) {
	for i := 1; i < len(arr); i++ {
		key := arr[i]
		j := i - 1
		for j >= 0 && arr[j] > key {
			arr[j+1] = arr[j]
			j--
		}
		arr[j+1] = key
	}
}

```

---
**Сортировка выбором (Selection Sort)**  

Находим минимальный элемент и ставим его в начало, потом повторяем для оставшейся части массива.  

Сложность: `O(n^2)`.

```go
package main

// SelectionSort — сортировка выбором
func SelectionSort(arr []int) {
	n := len(arr)
	for i := 0; i < n-1; i++ {
		minIdx := i
		for j := i + 1; j < n; j++ {
			if arr[j] < arr[minIdx] {
				minIdx = j
			}
		}
		arr[i], arr[minIdx] = arr[minIdx], arr[i]
	}
}

```

---
**Быстрая сортировка (Quick Sort)**  

Выбираем "опорный элемент" (pivot), делим массив на меньшие и большие, рекурсивно сортируем части.  

 Средняя сложность: `O(n log n)`. Одна из самых популярных сортировок.

```go
package main

// QuickSort — быстрая сортировка (рекурсивная)
func QuickSort(arr []int) []int {
	if len(arr) <= 1 {
		return arr
	}
	pivot := arr[len(arr)/2]
	left, right, middle := []int{}, []int{}, []int{}

	for _, v := range arr {
		if v < pivot {
			left = append(left, v)
		} else if v > pivot {
			right = append(right, v)
		} else {
			middle = append(middle, v)
		}
	}
	return append(append(QuickSort(left), middle...), QuickSort(right)...)
}

```

---
**Сортировка слиянием (Merge Sort)**  

Делим массив на две части, рекурсивно сортируем их и сливаем в один отсортированный массив.  

 Сложность: `O(n log n)`. Работает стабильно, но требует дополнительную память.

```go
package main

// MergeSort — сортировка слиянием
func MergeSort(arr []int) []int {
	if len(arr) <= 1 {
		return arr
	}
	mid := len(arr) / 2
	left := MergeSort(arr[:mid])
	right := MergeSort(arr[mid:])
	return merge(left, right)
}

func merge(left, right []int) []int {
	result := []int{}
	i, j := 0, 0
	for i < len(left) && j < len(right) {
		if left[i] < right[j] {
			result = append(result, left[i])
			i++
		} else {
			result = append(result, right[j])
			j++
		}
	}
	result = append(result, left[i:]...)
	result = append(result, right[j:]...)
	return result
}
```

---
**Бинарный поиск (Binary Search, рекурсивный)**  

Рекурсивно делим массив пополам и ищем элемент в нужной половине.  

Сложность: `O(log n)` по времени, `O(log n)` по памяти (из-за стека рекурсии).

```go

// 1 вариант через рекурсию
func binarySearchByRecursion(nums []int, target, left, right int) int {
	if left > right {
		return -1
	}

	mid := (left + right) / 2
	if nums[mid] == target {
		return mid
	} else if nums[mid] > target {
		return binarySearchByRecursion(nums, target, left, mid-1)
	} else {
		return binarySearchByRecursion(nums, target, mid+1, right)
	}
} 
```

--- 
**Бинарный поиск (Binary Search, итеративный)**  

Двигаем левый и правый указатели, пока не найдём элемент или не сузим диапазон до пустого.  

Сложность: `O(log n)` по времени, `O(1)` по памяти.

```go
// 2 вариант через итерации
func binarySearchByIterations(nums []int, target int) int {
	left, right := 0, len(nums)-1

	for left <= right {
		mid := (left + right) / 2
		if nums[mid] == target {
			return mid
		}
		if nums[mid] > target {
			right = mid - 1
		} else {
			left = mid + 1
		}
	}

	return -1
}
```

---

**Последовательность Фибоначчи (самая простая версия алгоритма)**:

```go
func fibo(n int) []int {  
    nums := make([]int, n)  
    for i := 0; i < n; i++ {  
       if i == 0 {  
          nums[i] = 0  
       } else if i == 1 {  
          nums[i] = 1  
       } else {  
          nums[i] = nums[i-1] + nums[i-2]  
       }  
    }  
  
    return nums
}
```

---
