## Сборщик мусора: 

Сборщик мусора (GC) работает одновременно с потоками программы (mutator threads), является type accurate (также известным как precise), и поддерживает выполнение нескольких поток сборки мусора параллельно.

Используется алгоритм параллельной маркировки и очистки (concurrent mark-and-sweep), в котором применяется барьер записи (write barrier).

GC не является поколенческим (non-generational) и не выполняет уплотнение памяти (non-compacting).

Выделение памяти осуществляется с помощью областей, сегрегированных по размеру и закрепленных за каждым процессом (per-P allocation areas), что минимизирует фрагментацию и устраняет необходимость в блокировках в типичных случаях.

---
```go
const (  
 _GCoff = iota (0)     // GC not running; sweeping in background, 
				       // write barrier disabled 
				   
_GCmark = 1            // GC marking roots and workbufs: 
			           // allocate black, write barrier ENABLED  
			    
_GCmarktermination = 2 // GC mark termination: allocate black, 
				       // P's help GC, write barrier ENABLED
)
```
---

##  Алгоритм работы GC разбивается на несколько шагов: 

## 1. Завершение очистки (sweep termination) : 

 Выполняется остановка всех процессов (stop-the-world). Это приводит все процессоры (P) к безопасной точке GC.
 
 Очищаются все неочищенные (unswept) блоки (spans). Такие блоки могут оставаться только в том случае, если текущий цикл GC был принудительно запущен  раньше ожидаемого времени.

---
## 2. Фаза маркировки (mark phase) :

a. Подготовка к фазе маркировки: 
- Установка значения `{go} gcphase` в  `{go} _GCmark` (из `{go} _GCoff`),
- активация барьера записи (write barrier), 
- включение помощи со стороны потоков-программы (mutator assist),
- постановка задач маркировки корней в очередь. 
Сканирование объектов не может начаться до тех пор, пока процессоры (P) не активируют барьер записи (write barrier). Это достигается с помощью stop-the-world.

b. Запуск мира (start-the-world). С этого момента работа GC выполняется:
- потоками-маркерами, запускаемыми планировщиком, 
- а также вспомогательными операциями, выполняемыми при выделении памяти. 
 Барьер записи обрабатывает как старое, так и новое значение указателя при любой записи указателя (см mbarrier.go). Новые выделенные объекты маркируются как черные.

c. GC выполняет задачи маркировки корней:
- сканирование всех стеков,
- маркировку глобальных переменных,
- маркировку указателей на кучу, находящихся в структурах рантайма вне кучи.
Сканирование стека останавливает текущую горутину, маркирует найденные на стеке указатели и затем возобновляет работу горутины.

d. GC опустошает очередь "серых" объектов, сканируя каждый серый объект до состояния "черного" и маркируя все найденные внутри указатели (что может в свою очередь, добавить новые объекты в очередь).

e. Так как работа GC распределена между локальными кешами, используется распределенный алгоритм завершения для определения момента, когда не останется ни задач маркировки, ни "серых" объектов (см `{go} gcMarkDone`). В этот момент GC переходит к этапу завершения маркировки.

---
## 3. Завершение маркировки (mark termination):

a. Выполняется остановка мира (stop-the-world).

b. Устанавливается значение `{go} gcphase = _GCmarktermination`, и отключаются рабочие потоки GC и вспомогательные операции.

c. Выполняются обслуживающие операции, например, сброс (flushing) кешей `{go} mcache`.

---
## 4. Фаза очистки (sweep phase) : 

a. Подготовка к фазе очистки: 

- Установка `{go} gcphase = _GCcoff`,
- настройка состояния очистки,
- отключение барьера записи.

b. Запуск мира (start-the-world). С этого момента новые выделенные объекты считаются "белыми",  выделение памяти при необходимости сопровождается очисткой блоков (spans) перед их использованием.

c. GC выполняет очистку в фоновом режиме и в ответ на выделение памяти. ([4b](#^4b))

---
## 5. Когда произошло достаточно много выделений памяти, последовательность действий повторяется, начиная с пункта 1.

---
## Подробнее о 4b: ^4b

## Конкурентная очистка (Concurrent sweep):

Фаза очистки выполняется параллельно с обычным выполнением программы.

Куча очищается блок за блоком (span-by-span) как "лениво" (в тот момент, когда горутина нуждается в блоке), так и конкурентно - в отдельной фоновой горутине. Это помогает программам не нагружать CPU.

В конце этапа Stop-the-world при завершении маркировки все блоки помечаются как требующие очистки (needs sweeping).

Фоновая горутина-"очиститель" просто последовательно ищет блоки один за другим.

Чтобы избежать запроса дополнительной памяти у ОС при наличии неочищенных блоков, горутина, нуждающаяся в новом блоке, сначала пытается вернуть в кучу достаточное количество памяти за счет очистки: 

-  если требуется блок для размещения малых объектов, очищаются блоки малых объектов того же размера до тех пор пока не будет освобожден хотя бы один объект.
- если требуется блок для размещения крупного объекта из кучи, очищаются блоки до тех пор, пока в кучу не будет возвращено достаточное количество страниц.

Есть один особый случай: если горутина очищает и освобождает два непоследовательных блока размером в одну страницу, а затем выделяет новый блок на две страницы, все еще могут оставаться неочищенные одностраничные блоки, которые при очистке можно было бы объеденить в блок на две страницы.

Крайне важно гарантировать, что никакие операции не выполняются над неочищенными блоками, поскольку это повредит биты маркировки в GC-битовой карте. 

Во время GC все `{go} mcache` сбрасываются в центральный кэш, поэтому они становятся пустыми. 
Когда горутина получает новый блок в `{go} mcache`,  она предварительно очищает его.

Если горутина явно освобождает объект или назначает финализатор, то она гарантирует, что соответствующий блок будет очищен (либо выполнив очистку, либо дождавшись завершения конкурентной очистки).

Горутина-финализатор запускается только тогда, когда все блоки очищены.

Когда начинается следующий цикл GC, он очищает все неочищенные блоки, если таковые остались.

---
## Частота запуска GC (GC Rate):

Следующий запуск GC происходит после того, как выделено дополнительное количество памяти, пропорциональное уже используемой памяти.

Например, если `{go} GOGC=100` и используется 4 МБ памяти, следующий GC будет выполнен при достижении 8 МБ (эта граница вычисляется методом `{go} gcController.heapGoal`).

Изменение значения `{go} GOGC` изменяет лишь коэффициент этой линейной зависимости (а также объем дополнительной используемой памяти).

- `{go} GOGC` управляет частотой запуска сборщика мусора (GC).
- Его значение — это **процент прироста к выделенной памяти с момента последнего GC**, при достижении которого снова запускается сборка мусора.

---
## Oblets:

`{go} maxObletBytes = 128 << 10` ^maxObletBytes

Чтобы предотвратить длительные паузы при сканировании крупных объектов и повысить уровень параллелизма, сборщик мусора разбивает задания сканирования для объектов, размер которых превышает [`{go} maxObletBytes`](#^maxObletBytes), на части oblets, размером не более maxObletBytes.

Когда при сканировании встречается начало крупного объекта, сначала обрабатывается только первый oblet, а оставшиеся oblets становятся в очередь как новые задания сканирования.

---

базовые типы, планировщик, сборщик мусора, память по хипу, интерфейсы, слайсы и старые мапы

