# Garbage Collector

## Что такое мусор?

**Мусор** — это неиспользуемые данные в памяти.

**Сбор мусора (GC)** выполняется:

- **Не всегда**: запуск происходит только при необходимости.
    
- **Причина**: GC — это оверхэд, так как требует ресурсов.
    

---

## Режимы управления памятью

### Ручной режим

```c
void* data = malloc(1024);
free(data);
```

### Автоматический режим

1. Подсчёт ссылок (Reference Counting)
    
2. Трассировка (Tracing)
    

---

## Подсчёт ссылок

**Принцип**:

- При аллокации объекта: `refcount++`
    
- При удалении ссылки: `refcount--`
    
- Когда счётчик = 0 → объект удаляется.
    

**Плюсы**:

- Простота
    
- Нет фоновых потоков для сканирования
    

**Минусы**:

- Оверхэд на `+/-` счётчика
    
- Дополнительная память
    
- Необходима синхронизация
    
- Синхронное освобождение длинных цепочек
    
- Проблемы с циклическими ссылками → решаются **слабыми ссылками** (weak refs)

---

## Трассировка (Tracing GC)

**Идея**:

- GC ищет _живые объекты_.
    
- Все потоки останавливаются (_Stop-the-World_).
    
- Из root set (стек потоков + глобальные переменные) строится граф ссылок.
    
- Используется трёхцветная маркировка.
    

**Три цвета:**

- **Чёрный** — исследован, все ссылки просмотрены.
    
- **Серый** — известен, но ещё не исследован.
    
- **Белый** — не исследован (мусор).
    
**Этапы:**

- **Sweep** — освобождаем белые объекты.
    
- **Copying** — живые объекты копируются в новое место, старое освобождается → меньше фрагментации.
    

**Недостаток**: чем больше куча, тем дольше пауза.

---

## Уменьшение пауз

- Обходить кучу частями → _поколенческий GC_.
    
- Пример:
    
    - Поколение 1: `a, b, c, d` → освободили `a, b`
        
    - Поколение 2: `c, d` → перенесли в старшее поколение.
        

---

## Concurrent GC и Parallel GC

- **Concurrent GC** — выполняется конкурентно с приложением (частично вместе с работой программы).
- **Parallel GC** — несколько потоков выполняют GC одновременно (ускоряет сборку, но всё ещё с паузами).

---

## GC в Go

### Алгоритм

- **Mark & Sweep**
    
- Трёхцветная маркировка
    
- **Конкурентный** GC с _write barrier_
    

### Ограничения

- GC использует до **25% CPU**
    
- Если не справляется → ограничивает аллокации и просит горутины помочь
    

### Условия запуска

1. Превышение динамического лимита кучи (`GOGC`)
    
2. Пауза > 2 минут → запускается GC автоматически (`sysmon`)
    
3. Ручной запуск через `runtime.GC()`
    

**Пример:**

- Очистка при куче = 1.5 Гб
    
- Следующий GC при росте ещё на **100%** (1.5 Гб → 3.0 Гб)


---
## Метрики памяти

- **RSS (Resident Set Size)** — сколько реально занято в RAM
    
- **VSZ (Virtual Memory Size)** — общий размер виртуальной памяти (адресное пространство, включая диск/кэш)

---
## Ballast

```go
ballast := make([]byte, 2<<30)
_ = ballast
```

- Используется для **разогрева** приложения, чтобы GC реже запускался.
    
- Расширяет _адресное пространство_ (VSZ), но фактически не занимает память (RSS увеличивается только при записи).
    
- Это **Lazy Allocation**.

---
## Пример с виртуальной машиной

- Лимит RSS = 10 Гб
    
- `GOGC = 100%`
    
- Хип = 5.1 Гб → следующий GC при 10.2 Гб
    
- Но процесс будет убит **OOM-killer**.

### Решения

- Настроить `GOGC`
    
- Избегать **Death Spiral**:
    - Нужно больше памяти → GC запускается чаще → больше CPU уходит на GC → меньше обрабатываем данных → запросы копятся.
        

### Современное решение

- **`GOMEMLIMIT`** — учитывает всю память процесса (а не только heap).
    
- GC ориентируется на верхний предел, чтобы избежать OOM.
    

---

## Финализаторы (Finalizers)

**Определение**: функция, вызываемая при освобождении объекта GC.

### Ошибки при использовании

1. Передача **не первого поля** в структуре
    
2. Ошибка в типах данных
    
3. Повторный вызов финализатора
    
4. Навешивание на объекты с циклическими ссылками