### Stack frame:

Стековый фрейм - это участок стека, который выделяется для выполнения конкретной функции. 

В нем обычно хранятся: 
- Адрес возврата (куда программа должна вернуться после завершения функции) ^returnAddress
- сохраненные регистры (чтобы восстановить состояние при выходе из функции) ^savedRegs
- локальные переменные ^localVar
- аргументы, передаваемые в другие функции ^args

### Примеры на `{go} Go`: 

1. [Адрес возврата:](#^returnAddress)

Это то место, куда программа должна вернуться после завершения функции.

```go
func A() int {
	return 42
}

func B() int {
	return A() // после вызова сюда вернёмся
}
```

2. [Сохраненные регистры:](#^savedRegs) 

Функция может временно использовать регистры, поэтому должна сохранить их, чтобы восстановить при выходе.

```go
func Save(x int) int {
	y := x + 5
	return y * 2
}
```

3. [Локальные переменные:](#^localVar)

В `{go} Go` компилятор часто кладет локальные переменные в стек, если они не помещаются в регистры или нужны для `{go} defer/recover`.

```go
func SumAndDouble(a, b int) int {
	c := a + b     // локальная переменная
	return c * 2
}
```

4. [Аргументы, передаваемые в другие функции:](#^args) 

Если функция вызывает другую и передает параметры, они тоже кладутся в стек (или в регистры - зависит от [ABI](ABI)). 

```go
func Add(a, b int) int {
	return a + b
}

func Caller(x, y int) int {
	return Add(x, y) // аргументы x, y передаются в Add
}
```

---
### Stack Frame Layouts
## x86
| Адрес/указатель         | Содержимое       | Комментарий                                                                           |
| ----------------------- | ---------------- | ------------------------------------------------------------------------------------- |
| ↑ (более высокий адрес) | args from caller | Аргументы, переданные этой функции                                                    |
| frame->argp             |                  | Указатель на начало аргументов                                                        |
|                         | return address   | Куда вернётся управление после `ret`                                                  |
|                         | caller's BP (*)  | Старый базовый указатель (EBP); сохраняется, если `framepointer_enabled && varp > sp` |
| frame->varp             |                  | Указатель на локальные переменные                                                     |
|                         | locals           | Локальные переменные текущей функции                                                  |
|                         | args to callee   | Аргументы, которые будут переданы следующей функции                                   |
| frame->sp (↓)           |                  | Текущий стековый указатель                                                            |

---

## ARM
|Адрес/указатель|Содержимое|Комментарий|
|---|---|---|
|↑ (более высокий адрес)|args from caller|Аргументы, переданные функции|
|frame->argp||Указатель на начало аргументов|
||caller's retaddr|Адрес возврата после завершения функции|
||caller's FP (*)|Старый FP (Frame Pointer); на ARM64 сохраняется, если `framepointer_enabled && varp > sp`|
|frame->varp||Указатель на локальные переменные|
||locals|Локальные переменные текущей функции|
||args to callee|Аргументы для следующей функции|
||return address|Адрес возврата для подфункции|
|frame->sp (↓)||Текущий стековый указатель|

---

**Примечание:**

`{go} varp > sp` → функция имеет фрейм. 
^varpHigherThanSP

`{go} varp == sp` → frameless функция
^varpEqualsSP
---
### BP/FP: ^BPFP

- BP - base pointer (x86)
- FP - frame pointer (ARM и более новые архитектуры)

Обе аббревиатуры обозначают указатель на базу стекового фрейма функции.

BP/FP - указатель на начало фрейма функции, т.е. "фиксированную точку", от которой мы можем обращаться к локальным переменным и аргументам.

В отличие от SP, BP/FP почти не меняется во время работы функции.

---
### Зачем нужен:

Локальные переменные и аргументы функции имеют фиксированное смещение относительно BP/FP.

Даже если SP двигается (push/pop), мы все равно можем достать `{go} local_var = [BP - 4]` или `{go} arg1 = [BP + 8]`.

---
### Variable Pointer(varp):
^varp

<font color="#c6d9f0">varp</font> - обычно указывает на начало локальных переменных функции (или на базу ее фрейма)

---
### Stack Pointer(sp): 
^sp

**<font color="#c6d9f0">sp</font>** - Вершина стека, т.е. адрес следующего свободного места в стеке.

---
### [Функция имеет фрейм:](#^varpHigherThanSP)
Если `{go} varp > sp`, значит в стеке есть пространство между вершиной стека и указателем на локальные переменные.

То есть функция создала собственный фрейм: сохранила [BP/FP](#^BPFP), выделила место для локалов и тд.

Это обычные функции, у которых есть локальные переменные и, возможно, сохраненные регистры.

### Пример:
``` go
frame->sp:   0x1000
frame->varp: 0x1080
```

→ между [sp](#^sp) и [varp](#^varp) есть 0x80 байт - это фрейм.

### Пример на `{go} Go`:
```go
package main

func SumAndDouble(a, b int) int {
	c := a + b     // локальная переменная
	return c * 2
}

func main() {
	sumAndDouble := SumAndDouble(2, 3)
	fmt.Println(sumAndDouble)
}
```

---
### [Функция без фреймов:](#^varpEqualsSP) 

Если `{go} varp == sp`, значит функция не создавала отдельного фрейма, вершина стека совпадает с указателем на локальные переменные.

Это frameless функция : 
- Нет сохраненных BP/FP
- Нет локальных переменных (или используются только регистры) 
- Стек почти не меняется

Обычно это короткие, оптимизированные функции, которые минимально трогают стек.

### Пример:
```go
frame->sp:   0x1000
frame->varp: 0x1000
```

→ нет выделенного пространства под фрейм.

### Пример на `{go} Go`:
```go
package main

func Add(a, b int) int {
	return a + b
}

func main() {
	sum = Add(2, 3)
	fmt.Println(sum)
}
```

---
### [Аллокация:](Allocation)