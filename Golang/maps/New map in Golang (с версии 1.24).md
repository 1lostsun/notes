
## Терминология:

| Термин           | Определение                                                                                                                                                                        |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **slot**         | место хранения одной пары (ключ/элемент).                                                                                                                                          |
| **group**        | группа из 8 слотов + контрольное слово.                                                                                                                                            |
| **control word** | 8-ми байтовое слово, указывающее, пуст ли слот, удален или используется. Если слот используется, то контрольный байт также содержит и младшие 7 битов хэша (h2).                   |
| **H1**           | старшие 57 бит хэша.                                                                                                                                                               |
| **H2**           | младшие 7 бит хэша.                                                                                                                                                                |
| **Table**        | полная хэш-таблица по схеме "Swiss table". Таблица состоит из одной или нескольких групп для хранения, а также метаданных для обработки операций и определения момента расширения. |
| **Map**          | тип `map` верхнего уровня состоит из нуля или более таблиц для хранения. Старшие биты хэша определяют к какой таблице относится ключ.                                              |
| **Directory**    | массив таблиц, используемых `map`.                                                                                                                                                 |
^header

---
В своей основе дизайн таблицы похож на традиционную хеш-таблицу с [открытой адресацией](Open-addressed-hash-table.md). 

**<u>Хранилище</u>** состоит из массива групп, то есть из массива слотов(ключ/значение) с контрольными словами между ними. 

**<u>Поиск</u>** использует хэш, чтобы определить начальную группу для проверки. Если из-за коллизий совпадений в группе нет, последовательность проб выбирает следующую группу для проверки.

---
Ключевое различие проявляется внутри группы. В обычной хэш-таблице с линейным [пробированием](Пробирование%20в%20хеш-таблицах.md) каждый слот проверяется по очереди. В "Swiss table" контрольное слово позволяет проверять все 8 слотов параллельно.

---
Каждый байт [контрольного слова ](#Терминология) соответствует одному слоту в группе. В каждом байте 1 бит указывает занят ли слот, пуст/удален.  Остальные 7 бит содержат в себе младшие 7 бит хэша ключа([H2](#Терминология))

Во время поиска можно использовать [побитовые операции](Побитовые%20операции.md), чтобы сравнить все 8 7-битных хэшей с входным хэшем параллельно. 
То есть фактически 8 шагов [пробирования](Пробирование%20в%20хеш-таблицах.md) выполняются за одну операцию.
С SIMD инструкциями это можно расширить до 16 слотов с 16-байтовым контрольным словом.

--- 
### [Пробирование](Пробирование%20в%20хеш-таблицах.md):
Пробирование выполняется с использованием старших 57 бит([H1](#Терминология)) хэша как индекса в массиве групп([group](#Терминология)). Алгоритм проходит по группам методом [квадратичного пробирования](Пробирование%20в%20хеш-таблицах.md#^quad-probing) до тех пор, пока не будет найдена группа с совпадением или пустым слотом.

**<u>Важно:</u>** число групп должно быть степенью двойки, и последовательность групп должна заканчиваться группой с пустым слотом (таблица никогда не может быть заполнена на 100%).

---
### Удаление:

Пробирование останавливается при встрече с пустым слотом. Это влияет на удаление : если удалять из полностью заполненной группы,  слот нельзя помечать пустым, иначе поиск прервется слишком рано. 

Вместо этого слот помечается как "удаленный" (tombstone). Если в группе есть пустой слот, tombstone не нужен - слот сразу помечается пустым. 

Вставка сначала использует tombstone, а потом помечает слот пустым. Полностью tombstones очищаются только при росте `map`, тк очистка "на месте" усложнила бы итерацию. 

---
### **Рост**: 
`{go} const maxTableCapacity = 1024`
^maxTableCapacity

Последовательность проб зависит от числа [групп](#Терминология). Поэтому при увеличении числа групп все слоты нужно распределить по новой последовательности. Иными словами, вся таблица увеличивается сразу.

Для поддержки постепенного роста, `map` делится на несколько таблиц. Каждая таблица - это полноценная хэш-таблица, но она обслуживает лишь часть хэш-пространства.

Рост происходит на уровне отдельных таблиц, так что каждая операция затрагивает только часть `map`. 

Максимальный размер роста отдельной таблицы ограничен путем ограничения максимального размера изначальной таблицы перед ее разбиением на несколько таблиц.

`Map` начинается с одной таблицы. До [[maxTableCapacity](#^maxTableCapacity)]  рост выполняется путем замены таблицы на бОльшую с удвоенной емкостью и последующим разбиением ее на две таблицы.

---
`Map` использует расширяемое хэширование (extendible hashing) для выбора таблицы. Здесь старшие биты хэша([H1](#Терминология)) используются как индекс в массиве таблиц (называемый директорией). ^directory

Количество используемых бит увеличивается  при росте числа таблиц. 

<u>Например: </u> 
Если имеется только 1 таблица, мы используем 0 бит (выделение не требуется). Если имеется 2 таблицы, мы используем 1 бит для выбора, либо 1-ой, либо 2-ой таблицы. [`{go} Map.globalDepth`]   - это число бит, используемых в настоящее время для выбора таблицы, и соответственно (1 << globalDepth), размера директории. 

Обратим внимание, что каждая таблица имеет свой коэффициент загрузки и растут они независимо. Если первая таблица растет, то она разделится на 2. Однако для выбора нам потребуется 2 бита, хотя таблиц у нас станет 3, а не 4.

Это поддерживается тем, что несколько индексов могут указывать на одну и ту же таблицу.

<u>Пример:</u>

directory (globalDepth=2)

| Directory | →   | Table                  |
| --------- | --- | ---------------------- |
| `00`      | →   | Table (localDepth = 1) |
| `01`      | →   | Table (localDepth = 1) |
| `10`      | →   | Table (localDepth = 2) |
| `11`      | →   | Table (localDepth = 2) |
Таблицы хранят глубину создания (localDepth). 
Необходимо увеличить объем [директории](#^directory) при разбиении, когда `localDepth == globalDepth`.

---
### Итерация:

Итерация - самая сложная часть работы с `map` из-за достаточно "свободных" семантик итерации в `Go`. 

Краткое резюме семантики из спецификации: 
1. Добавление и/или удаление записей во время итерации НЕ ДОЛЖНО приводить к повторному возврату одного и того же элемента.
2. Записи, добавленные во время итерации, МОГУТ быть возвращены итератором.
3. Записи, измененные во время итерации, должны возвращать свое АКТУАЛЬНОЕ значение.
4. Записи, удаленные во время итерации, **НЕ ДОЛЖНЫ** приводить к возврату удаленного элемента.
5. Порядок обхода не определен. В реализации он специально рандомизируется.

--- 
Если `map` НЕ РАСТЕТ в процессе итерации, то суть простая : нужно пройтись по каждой таблице в [директории](#^directory), каждой группе и каждому слоту в таблицах.
Эти правила при этом соблюдаются автоматически.

---
Если `map` растет во время итерации, то ситуация значительно усложняется. Прежде всего, нужно отслеживать, какие элементы уже были возвращены, чтобы выполнить условие **(п.1)**.

Существует 3 типа роста : 

a - Таблица заменяется одной более крупной таблицей. 
b - Таблица делится на две новые таблицы. 
c - Увеличение размера директории (происходит как часть варианта b, если необходимо) ^abc

---
Во всех случаях новые таблицы имеют иную последовательность проб, поэтому простого отслеживания текущей группы и индекса слота недостаточно.

Для случаев [a](#^abc) и [b](#^abc) важно, что рост таблиц, отличных от той, по которой мы сейчас итерируемся, не имеет значения.

Мы обрабатываем [a](#^abc) и [b](#^abc) так: итератор сохраняет ссылку на таблицу, по которой он итерируется в данный момент, даже, если она уже была заменена. Продолжая обход именно старой таблицы, мы сохраняем порядок итерации и избегаем нарушения **(п.1)**. 

Любые новые элементы, которые были добавлены **ТОЛЬКО В НОВЫЕ ТАБЛИЦЫ**, будут пропущены (что разрешено п.2). 

Чтобы не нарушить (п.3) и (п.4), при выборе ключей мы используем старую таблицу, но затем повторно ищем их уже в новых таблицах, чтобы определить были ли они изменены или удалены. 

Дополнительная сложность появляется в случае, если ключи не сравниваются напрямую с равным. 

Следует учитывать, что в случае [b](#^abc), когда мы завершаем обход старой таблицы, нужно пропустить следующую запись в директории, тк там хранится вторая часть разделенной таблицы. 

Для определения следующего логического индекса можно использовать `localDepth` старой таблицы. 

Также при [b](#^abc) нужно корректировать текущий индекс в директории, если каталог увеличился. Это относительно просто, тк порядок в директории сохраняется после роста, следовательно достаточно просто удвоить индекс, если размер директории увеличился.

--- 

## <font color="#c3d69b">Кодовые представления описанных выше действий:</font>

>  Функция выделяет **H1**, то есть старшие 57 бит хэша.
> (На 32 разрядной системе выделит 32-7 бит == 25)

```go
func h1(h uintptr) uintptr {
	return h >> 7
}
```
---


> Функция достаёт `H2` — **7 младших бит хэша**, которые не вошли в `H1`.
> 
> Эти биты идут в _control byte_ (контрольный байт), который хранится в каждой группе бакетов Go map.
> 
> Побитовое И (&) оставляет только 7 младших бит числа `h`, а все старшие обнуляет.
    

```go
func h2(h uintptr) uintptr {
	return h & 0x7f 
	// 0x7f в двоичном виде: `01111111` 
	// (7 единиц в младших битах).
}
```
---
>Структура `Map`

```go 
type Map struct {
	// число заполненных слотов 
	// (количество элементов во всех таблицах)
	// исключает удаленные слоты.
	used uint64 
	
	// seed — случайное число, генерируемое Go при создании каждой `Map`, 
	// подмешивается в хэш-функцию для уникальности хэшей
	// и защиты от предсказуемых коллизий.
	seed uintptr
	
	// обычно dirPtr указывает на массив указателей на таблицы :
	// dirPtr *[dirLen]*table
	
	// Длина этого массива (dirLen) : 
	// 1 << globalDepth 
	// Несколько элементов могут ссылаться на одну таблицу.
	
	// Оптимизация для маленьких мап : если в мапе всегда содержится 
	// 8 (abi.SwissMapGroupSlots) или меньше элементов, 
	// то вся мапа помещается в одну группу. 
	// dirPtr в этом случае указывает напрямую на группу, 
	// а dirLen == 0.
	// Маленькие мапы никогда не имеют удалённых слотов, 
	// тк последовательность пробирования отсутствует.
	dirPtr unsafe.Pointer
	dirLen int
	
	// Количество бит, 
	// используемых для поиска в директории таблицы.
	globalDepth uint8
	
	// Количество бит, 
	// которые нужно сдвинуть из хэша для поиска по таблице.
	// В 64-разрядных системах globalShift == 64
	globalShift
	
	// Флаг, который переключается (XOR 1) во время записи в мапу.
	// Обычно устанавливается в 1 при записи,
	// но при нескольких параллельных писателях 
	// переключение увеличивает вероятность обнаружения гонки
	wrtitig uint8
	
	// Последовательность-счетчик вызовов очистки. Используется
	// для обнаружения очистки мапы во время итерации.
	clearSeq uint64
}
```
---
