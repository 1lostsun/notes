## **Интегрированный сетевой поллер** (network poller, независимая от платформы часть).

Конкретная реализация поллера (например, **epoll**, **kqueue**, **port**, **AIX**, **Windows**) должна определить следующие функции :

> `{go} func netpollinit()`
> 
>  Инициализирует сетевой поллер.
> 
>  Вызывается только один раз при запуске программы.

---

>`{go} func netpollopen(fd uintptr, pd *pollDesc) int32`
>
>  Активирует **уведомления с "edge-triggered"** (по фронту) для файлового дескриптора `{go} fd`.
> 
>  Аргумент `{go} pd` используется, чтобы передать его обратно в `{go} netpollready`, 
>  когда дескриптор `{go} fd` становится готов к операции.
>  Возвращает код ошибки (errno).

---

> `{go} func netpollclose(fd uintptr) int32`
> 
>  Отключает уведомления для данного файлового дескриптора `{go} fd`.
>  Возвращает код ошибки (errno).

---

> `{go} func netpoll(delta int64) (gList, int32)`
> 
>  Выполняет операцию опроса сети (*polling*).
> 
> 	Если delta < 0 - блокируется бессрочно;
> 	Если delta == 0 - выполняет неблокирующий опрос;
> 	Если delta > 0 - блокируется не дольше delta миллисекунд.
> 
>  Возвращает : 
> 	Список горутин (gList), сформированный через вызовы `{go} netpollready`;
> 	Значение delta, которое прибавляется к `{go} netpollWaiters`, когда все горутины готовы.
> 
>  Функция **не должна** возвращать пустой список, если возвращаемое delta - ненулевое.

---

> `{go} func netpollBreak()`
> 
>  **Пробуждает сетевой поллер**, если он в данный момент **заблокирован** внутри `{go} netpoll`.

---

> `{go} func netpollIsPollDescriptor(fd uintptr) bool`
> 
>  Возвращает `{go} true`, если `{go} fd` - это файловый дескриптор, 
>  используемый самим сетевым поллером (для его внутренней работы).

---
### Коды ошибок: 

```go
const (  
  pollNoError        = 0 // no error  
  pollErrClosing     = 1 // descriptor is closed  
  pollErrTimeout     = 2 // I/O timeout  
  pollErrNotPollable = 3 // general error polling descriptor  
)
```

---

> `{go} polldesc` 
> 
>  содержит два двоичных **семафора** - `{go} rg` и `{go} wg`, 
>  используемых для **парковки (ожидания)** горутин, выполняющих операции 
>  чтения и записи соответственно.

---
### Каждый семафор может находиться в одном из следующих состояний:

 > `{go} pdReady`
 > 
 >  Уведомление о готовности ввода-вывода (I/O readiness) ожидает обработки.
 >  Горутина **потребляет** (использует) это уведомление, изменяя состояние на `{go} pdNil`.

  > `{go} pdWait`
  > 
  >  Горутина **готовится к парковке** на семафоре, 
  >  но **еще не припаркована**. 
  >  
  >  На этом этапе возможны три варианта событий: 
  >  
  > 	1. Горутина фиксирует намерение припарковаться, 
  > 	изменяя состояние на указатель на себя (G pointer).
  > 	
  > 	2. Одновременно поступает уведомление о готовности I/O, 
  > 	которое изменяет состояние на pdReady.
  > 	
  > 	3. Одновременно происходит таймаут или закрытие дескриптора, 
  > 	и состояние изменяется на pdNil.
  
  > `{go} G pointer`
  > 
  >  Семафор содержит **указатель на горутину**,
  >  которая **заблокирована** (припаркована) на этом семафоре.
  >  
  >  В этом состоянии: 
  > 
  > 	Уведомление о готовности I/O изменяет состояние на pdReady,
  > 	а таймаут или закрытие дескриптора изменяют состояние на pdNil.
  > 
  >  после чего горутина разблокируется (unpark).
  
  >  `{go} pdNil`
  >  
  >  Ни одно из вышеперечисленных состояний не активно - **семафор свободен**.
  
---
Состояния семафоров `{go} rg` и `{go} wg` : 

```go 
const (  
  pdNil   uintptr = 0  
  pdReady uintptr = 1  
  pdWait  uintptr = 2  
)
```

---
NetPoller — это отдельная часть планировщика, который управляет сетевыми операциями (например, асинхронными I/O операциями). Он может работать вне контекста стандартных горутин, особенно при обработке событий с использованием системных вызовов, таких как poll или epoll на Linux.

---