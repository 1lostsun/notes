## 3 модели для нарезания вычислений на потоки: 

1. `N:1` - несколько потоков запущено на едином потоке ядра ОС. 
   Преимущество - осуществляется очень быстрое переключение контекстов, 
   но нет возможности воспользоваться многоядерностью.
2. `1:1` - каждый поток выполнения совпадает с одним потоком ОС. 
   Подход использует все ядра автоматически, 
   но переключение контекста происходит очень медленно,
   потому что требует прерывания работы ОС.
3. Go старается взять лучшее из обоих подходов с помощью `M:N` планировщика.
   При этом произвольное число горутин `M` планируется на произвольное количество потоков `N` ОС.
   Получается одновременное переключение контекста + возможность пользоваться многоядерностью.
   Основной недостаток подхода заключается в сложности включения его в планировщик.

---
## GMP модель: 

`M (Machine)` - thread операционной системы. 
Точнее абстракция над ним. В `go runtime` представлена в виде масштабной структуры.
Выполнением такого потока управляет операционная система, и работает это во многом подобно стандартным потокам `posix`.

- `M` создаются по мере необходимости (но ограничены `GOMAXPROCS`);
- Если горутина блокируется `syscalls`, создается новый `M`;
- `System monitor` завершает неиспользуемые `M` через `forcegc` (чтоб не накапливались лишние потоки).

`G (Goroutine)` - легковесный поток (горутина). Он включает в себя [стек](stack), 
указатель команд и другую важную информацию для планирования горутиы, 
например, канал который на ней не может быть заблокирован.

`P (Processor)` - Планировщик на ядре. Можно понимать 
как локальную версию планировщика с собственной очередью горутин 
под конкретный `M` с каким-то контекстом (регистры и тд).

---

## Локальная (LRQ) и Глобальная (GRQ) очереди:

### В планировщике Go есть две очереди выполнения: 

- Глобальная (GRQ); 

- Локальная (LRQ) - может хранить в себе до `256` горутин (FIFO) 
  однако, есть такая оптимизация, что последняя горутина, может выполниться первой,
  без очереди : одноэлементный стек LIFO. 

  Это сделано потому, что существует ненулевая вероятность того, 
  что на `M` уже установлен контекст выполнения, подходящий именно для этой горутины.
  Поэтому часто имеет смысл запустить ее раньше остальных.

Каждому `P` соответствует локальная очередь (LRQ), которая управляет горутинами, 
назначенными для выполнения в контексте `P`.

Эти горутины поочередно подключаются и отключаются от `M`, закрепленного за данным `P`.
Глобальная очередь (GRQ) хранит горутины, которые еще не были назначены ни одному `P`.
Существует механизм, позволяющий перемещать горутины из GRQ в LRQ. 

![[Pasted image 20251019142453.png]]

---

```go
runtime.schedule() { 
	// only 1/61 of the time, check the global runnable queue for a G. 
	// if not found, check the local queue. 
	// if not found, 
	// try to steal from other Ps. 
	// if not, check the global runnable queue. 
	// if not found, poll network. 
}
```

- С вероятностью 1/61 немедленно проверить `GRQ` и запустить горутину оттуда.
  Число 61 выбрано не случайно, а так, чтобы оно не было слишком маленьким, 
  что приводило бы к чрезмерно частой проверке `GRQ` 
  и не слишком высоким, чтобы не привести к голоданию горутин в `GRQ`.

- Приоритетнее запускать `G` в своей собственной `LRQ`.
- Затем из `LRQ` в других `P`. Воруется` 1/2 ` локальной очереди другого (случайного) `P`
  ( по умолчанию, `128` из `256` возможных). Это называется `work-stealing` и противопоставляется `work-sharing`.
  Интересная деталь : **work-stealing** в Go не очень агрессивен, 
  поэтому иногда загрузка ядер может быть неравномерной.
- Затем из `GRQ`;
- Затем из `netpoller`;

Если горутины нет, поток засыпает (`{go} park()`), а `System Monitor` позже его разбудит.

---
## Sysmon:

`sysmon` - это фоновый поток, который выполняет системные служебные задачи `Go runtime`.
Он **не выполняет горутины**, а следит за состоянием системы, 
работой вашего приложения и помогает справиться с узкими местами, 
с которыми может столкнуться ваша программа. 

**Не связан ни с одним `P`, `M` или `G`** в нашей модели.

### Задачи `sysmon` : 
- Обнаруживает `M`, зависшие в `syscall` : 
	- Если `M` завис в `syscall` (`syscall` длится более 10 мс), `sysmon` запускает новый `M`, чтобы `P` не простаивал.
	- Когда `syscall` завершается, `G` возвращается в очередь, а `M` либо продолжает работать, либо паркуется.
- Обслуживает `netpoller` : 
	- Обрабатывает **неблокирующие I/O** (`net`, `epoll`, `kqueue`, `IOCP`). 
	 То есть проверяет сетевые события (`epoll/kqueue/IOCP`) и пробуждает `G`, ждущие данные.
	 Перемещает горутины из `netpoller` в `GRQ`, если они живут там больше 20 мс.
- Пробуждает `P`, если он долго простаивает :
	- Если `P` ничего не делал больше 10 мс, `sysmon` дает ему работу **из глобальной очереди (`GRQ`)**.
- Запускает `forcegs` (форсированный [`GC`](Garbage%20Collector)) : 
	- Если горутины долго не доходят до `{go} runtime.GC()`, `sysmon` запускает его принудительно.

### Как `sysmon` управляет `M`, зависшими в `syscalls` : 

Допустим, `G` делает блокирующий `syscall`, например, `{go} read()`:

1. `M` блокируется, выполняя `syscall`;
2. `P` отвязывает `M` (`{go} handoff()`), чтобы не простаивать и ищет новый `M`;
3. Если нет свободного `M`, `sysmon` создает новый `M`, чтобы `P` продолжил работу;
4. Когда `syscall` завершится, `M` **не возвращается к своему `P`**, 
   а отправляет `G` в `GRQ`;
5. Далее `M` либо продолжает работать, если есть свободный `P`, либо паркуется.

`sysmon` также не учитывается в планировщике Go. 
Он всегда запущен, но достаточно умен, чтобы не потреблять ресурсы, когда нечего делать.
Время его цикла динамично и зависит от текущей активности выполняемой программы.

Любая горутина, выполняющаяся более `10 мс`, помечается как вытесняемая (мягкое ограничение).
Поэтому планировщик Go может решить, следует ли вернуть ее в `LRQ` или продолжить выполнение в потоке. 

---

## Netpoller:

В отличие от `syscall`, который блокирует `M`, 
`Netpoller` позволяет горутине ждать данные без блокировки потока.

`Netpoller` - слой абстракции над системными `API` для асинхронного I/O (`epoll/kqueue/IOCP`).

Когда `G` делает `{go} net.Conn.Read()`, Go не блокирует `M`, а : 

1. Регистрирует сокет в `Netpoller` (`epoll/kqueue`);
2. Переключает `G` в состояние `_Gwaiting`;
3. `P` продолжает выполнять другие горутины, а `M` не простаивает;
4. Когда данные поступают, `sysmon` пробуждает `G` и ставит ее в очередь с состоянием `_Grunnable`.

В результате `M` остается свободным, можно обслуживать тысячи горутин на одном `M`.

То есть, когда горутина ждет сетевой запрос (например, ожидает на узле), 
она добавляется в `Netpoller`. 

Таким образом, горутина не блокирует основной поток ядра. 
Вместо этого она терпеливо ожидает в очереди  `Netpoller`, позволяя другим горутинам свободно выполняться.

### Взаимодействие `sysmon` и `Netpoller`: 

- `sysmon` каждые 10 мс проверяет `Netpoller`;
- Если есть активные события (`epoll_wait/kqueue_wait`), `sysmon` пробуждает горутины;
- Это позволяет обрабатывать сетевые соединения **без блокировки `M`**.

---
## Тип многозадачности: 

Бывает два типа многозадачности : 

- Вытесняющая;
- Кооперативная.

### Вытесняющая: 

С **не кооперативной (вытесняющей)** многозадачностью все прекрасно знакомы на примере планировщика ОС.
Данный планировщик работает в фоне, выгружает потоки на основании различных эвристик,
а вместо выгрженных, процессорное время начинают получать другие потоки.

### Кооперативная:

Для **кооперативного** планировщика характерно другое поведение - он спит пока одна из горутин явно не разбудит его с намеком о готовности отдать свое место другой.
Планировщик далее сам решит, надо ли убирать из контекста текущую горутину, 
и если да, кого поставить на ее место.

Примерно так раньше и работал планировщик Go.

В Go 1.14 изменился принцип работы планировщика, 
рассмотрим причины по которым эти изменения были сделаны. 

Пример кода на версии Go >1.14: 

```go
func main() {
    runtime.GOMAXPROCS(1)
    go func() {
        var u int
        for {
            u -= 2
            if u == 1 {
                break
            }
        }
    }()
    <-time.After(time.Millisecond * 5) // в этом месте main горутина разбудит планировщик, 
									   // а он в свою очередь запустит горутину с циклом

    fmt.Println("go 1.13 has never been here")
}

```

Если скомпилировать этот код с версией **GO < 1.14**,  то строчку `{go} go 1.13 has never been here` вы не увидите на экране.
Происходит это потому, что, как только планировщик дает процессорное время горуитине с бесконечным циклом,
она всецело захватывает `P`, внутри это горутины не происходит никаких вызовов функций, 
а значит планировщик мы больше не разбудим. 

И только явный вызов `{go} runtime.Gosched()` даст нашей программе завершиться.

Раньше `{go} runtime.Gosched()` использовал `safe points` места,
где точно можно вызвать планировщик без боязни, что мы попадем в атомарную для `GC` секцию кода.

Как мы уже говорили, данные `safe points` располагаются в прологе функции 
(но далеко не каждой функции, заметьте). Если вы разбирали гошный ассемблер, 
то могли бы возразить - никаких очевидных вызовов планировщика там не видно. 

Да, это так, но вы можете найти там инструкцию вызова **`runtime.morestack`**, 
а если заглянуть внутрь этой функции, то обнаружится вызов планировщика.

Раньше планировщик, в моменте, когда решал, что горутина выполняется слишком долго, 
выставлял ей свойство `stackguard`, а уже сама горутина проверяла его, 
и отдавала управление, если видела, что был запрос на это дело.

С версии Go 1.14 используется ОС сигнал `SIGURG` для того, 
чтобы прервать горутину, которая занимает слишком много времени. 

---
## Состояния горутин (`G`): 

- `_Gidle` (Неактивная): 
	- Горутина не используется (еще не запущена или завершилась и ожидает переиспользования).
	- Обычно такие структуры `g` находятся в **пуле горутин (`freelist`)**,
	 откуда их можно переиспользовать.
- `_Grunnable` (Готовая к выполнению):
	- Горутина, готовая к запуску, но еще не выполняющаяся.
	- Она находится в очереди выполнения у `P` (`LRQ`) или в глобальной (`GRQ`) очереди планировщика.
- `_Grunning` (Выполняется) :
	- Горутина активно выполняется на одном из `M` (на потоке ОС).
	- В этот момент планировщик **не может ее прервать**, 
	  пока не произойдет блокирующая операция.
- `_Gwaiting` (Ожидание) : 
	- Горутина заблокирована и ждет внешнего события:
		- `Syncronization calls` - Синхронизационные вызовы 
		 (атомарные операции, мьютексы, операции с каналами, системные вызовы);
	    - `Asynchronous calls` - Асинхронные вызовы (сетевые вызовы);
	    - Ожидание `sync.Mutex`;
	    - `{go} time.Sleep()`;
	    - Ожидание в `{go} select{}`.
	- В этом состоянии горутина **не находится в очереди выполнения**, 
	 пока не получит сигнал от события.
- `_Gsyscall` (Системный вызов): 
	- Горутина выполняет **блокирующий системный вызов**, например: 
	    - Чтение/запись в файл (`os.Open()`, `os.ReadFile()`);
	    - Сетевые операции (`net/http`, `net.Dial()`);
	    - **Разница с `_Gwaiting`** - тут блокируется системный поток (`M`),
	      и поэтому `Go runtime` может создать новый `M`, 
	     чтобы продолжить выполнение других горутин.
- `_Gdead` (Завершена) : 
	- Горутина завершилась (`return`, `panic` или `{go} runtime.Goexit()`).
	- Ее структура (`g`) **может быть переиспользована** для новых горутин.
- `_Gcopystack` (Перемещение стека) : 
	- Горутина **меняет размер стека**, потому что стек в Go динамический 
	 (начинается с 2 - 4 KB и растет при необходимости);
	- Это временное состояние, когда Go **копирует стек горутины в новую область памяти**.
	- Как это работает : 
	    - Горутина создается (`{go} newproc()`) и становится `_Grunnable`;
	    - `P` ставит ее в локальную очередь (`LRQ`);
	    - `M` забирает ее и запускает → **`_Grunning`**;
	    - Если горутина блокируется (`syscall`, ожидание chan и тд) → **`_Gsyscall` или `_Gwaiting`**;
	    - Когда `syscall` или ожидание завершается → горутина возвращается в **`_Grunnable`**;
	    - Если горутина завершилась → `_Gdead` и памят под нее чистит `GC`.
---

## Что делает `{go} park()`: 

Функция `{go} park()` в `Go runtime` используется для **остановки** (заморозки) текущего `M` (потока ОС),
когда у него нет активных горутин.
Она является частью внутреннего механизма планировщика.

Когда `M` паркуется: 
- **Остановка потока** `M`, когда у него нет работы;
  Если `M` (поток ОС) выполнил все доступные горутины и в системе больше нет задач, 
  он "паркуется" (переходит в спящее состояние) до тех пор, 
  пока не появится новая работа.
- **Блокировка** `M` во время `syscall`:
  Когда `M` выполняет **блокирующий системный вызов**, 
  например, `{go} read(), write()`, то `Go runtime` может перевести `M` в `park` и переключиться на другой поток.
- **Остановка** `M` при **уменьшении количества потоков `(GOMAXPROCS)`**:
  Если значение `GOMAXPROCS` уменьшается, некоторые `M` могут стать **избыточными** и `Go runtime` отправит их в `park`.

Как это выглядит: 
- `M` понимает, что у него нет работы;
- `M` вызывает `{go} park()`, освобождая ресурсы ОС;
- Если появится новая работа, `P` разбудит `M` через `{go} runtime.notewakep()`.

---

## Что делает `{go} handoff()`: 

Функция `{go} handoff()` используется, чтобы **переназначить** `P` другому `M`, 
если текущий `M` заблокировался (`syscall`).

Функция `{go} handoff()` в Go используется внутри планировщика для передачи `P` **от одного** `M` **другому**.
Это необходимо, **когда поток `M` заблокировался ожидая `syscall`** и планировщик хочет, 
чтобы  работа `G` не простаивала.

### Как это работает: 
- `G1` выполняется на `M1` (привязан к `P1`);
- `G1` совершает `syscall`, `M1` блокируется (`_Gsyscall`);
- `{go} handoff()` отвязывает `M1` от `P1`, после чего `P1` находит `M2`, чтобы не простаивать;
- `M2` теперь выполняет горутины `P1`; 
- Когда `syscall` завершится, `M1` отправит `G1` в `GRQ`, а сам припаркуется.

В `Go runtime` решение о том, делать немедленный `{go} handoff()` или оставить поток заблокированным, 
принимает **системный монитор (`sysmon`)** и логика планировщика.

Когда вы вернетесь из `handed-off syscall`, планировщик Go выполнит следующие действия:

- Если старый `P` (тот с которого был передан поток) доступен, горутина будет назначена в его `LRQ`;
- Если старый `P` **недоступен**, горутина будет привязана к любому свободному процессору;
- Если нет свободных процессоров, горутина будет добавлена в `GRQ`.

---
## Кто создает новую горутину: 

Горутины создаются с помощью `{go} go func()`, что вызывает `{go} runtime.newproc()`.

### Алгоритм `{go} newproc()`:
- Берет `P` текущего `M`, на котором выполняется `{go} go func()`;
- **Выделяет новый объект `G`**, инициализирует его стек и состояние;
- Добавляет `G` в `LRQ` `P`, если есть место;
- Если `LRQ` `P` заполнена (`256 G`), некоторые `G` сбрасываются в `GRQ`.

---

## Что работает в обход `GMP`:

В Go есть несколько аспектов, которые могут выполняться в обход `GMP`-модели: 

- `GC`(Сборщик мусора):
    - Сборщик мусора выполняется в отдельном потоке, 
	  и хотя он использует планировщик Go, он может делать это в фоновом режиме,
	  не связанный напрямую с планированием горутин.
    - В процессе работы `GC` может вмешиваться в планирование, 
	  например, при необходимости приостановить выполнение горутин, 
	 чтобы выполнить сборку мусора.
- `Netpoller`: 
	- Это отдельная часть планировщика, которая управляет сетевыми операциями 
	 (например, асинхронными `I/O` операциями).
	- Он может работать вне контекста стандартных горутин,
	 особенно при обработке событий с использованием системных вызовов, 
	 таких, как `poll` или `epoll` на Linux.
- `sysmon`:
	- Это фоновая горутина, которая выполняется для мониторинга системных процессов,
	 включая работу с таймерами, очистку ресурсов и сбор информации о состоянии системы.
- Программное окружение (`runtime environment`):
	- Некоторые части `Go runtime`, такие как управление управление стеками и кучей 
	 (например, переподключение горутин при увеличегнии стека),
	 также выполняется в фоновом режиме и могут не подчиняться полной `GMP`-модели.

Таким образом, несмотря на то, что основная часть работы Go-среды основывается на `GMP`-модели,
есть несколько фрагментов кода, которые работают в фоновом режиме, 
не имея прямой связи с ней, такие как `GC`, `Netpoller`, и `sysmon`.

---