## Scheduler (Планировщик): 

Основная задача планировщика - распределять готовые к выполнению горутины между рабочими потоками.

Основные понятия : 
- G - goroutine (Горутина).
- M - machine (Машина), рабочий поток.
- P - processor (Процессор), ресурс, необходимый для выполнения кода на го. ^P
---
Рабочий поток (М) должен быть связан с процессором (Р), чтобы выполнять GO код. Однако поток может быть заблокирован или быть в системном вызове (syscall) без связанного Р. 

---
## Парковка и распарковка рабочих потоков:

Необходимо поддерживать баланс между количеством активных рабочих потоков, достаточным для эффективного использования доступного аппаратного параллелизма, и парковкой избыточных потоков, чтобы экономить системные ресурсы, CPU и энергию.

Реализация этого баланса сложна по двум причинам : 
1. Состояние планировщика намеренно распределено (в частности, имеются отдельные очереди задач на каждый [процессор](#^P)), поэтому невозможно вычислять глобальные условия на "быстрых" путях выполнения.

```go 
Планировщик Go (распределённое состояние)

Каждый P имеет свою локальную очередь (runq) для G.
Быстрые пути (fast-path) работают только с локальной runq без глобальных блокировок.
Глобальные операции (slow-path) происходят при переполнении, краже или глобальной синхронизации.

+------------------------------------------------------------------+
|                          Global State                            |
+------------------------------------------------------------------+
|    Global runq  | Idle Ps | Global timers | Sysmon | GC | ...    |
+------------------------------------------------------------------+
         ^                       ^                       ^
         |                       |                       |
         | (slow path)           | (slow path)           | (slow path)
         |                       |                       |
+-----------------+     +-----------------+     +-----------------+
|        P1       |     |        P2       |     |        P3       |
+-----------------+     +-----------------+     +-----------------+
|runqueue: [G1,G2]|     |  runqueue: [G3] |     |runqueue: [G4,G5]|
|  local caches   |     |  local caches   |     |  local caches   |
|  timers         |     |  timers         |     |  timers         |
+-----------------+     +-----------------+     +-----------------+
      ^      ^                ^      ^                 ^      ^
      |      |                |      |                 |      |
      |      |                |      |                 |      |
  +---+      +---+        +---+      +---+         +---+      +---+
  |      M1      |        |      M2      |         |      M3      |
  +--------------+        +--------------+         +--------------+
  | executing Gs |        | executing Gs |         | executing Gs |
  +--------------+        +--------------+         +--------------+

work-stealing (fast/slow hybrid):
   func stealWork(now int64) (gp *g, inheritTime bool, rnow, pollUntil int64, newWork bool)
   proc.go 3731 str
    
`Work stealing` — когда один `P` берёт задачи у другого, это согласуется через локальные очереди и обычно активирует более медленный путь на момент кражи (или использует специальные атомарные операции).

`runqueue` — локальная очередь задач для каждого `P`.

`Fast path` — операции, выполняемые локально без обращения к глобальным структурам 
(обычно `lock-free` или с минимальной синхронизацией).
Быстрый путь не может корректно/эффективно вычислять глобальные условия.

`Slow path` — ситуации, требующие глобальной синхронизации: 
блокировки, глобальные счётчики, балансировка нагрузки, GC, изменение числа `P` и т.п.

```

2.  Для оптимального управления потоками потребовалась бы информация о будущем - например, чтобы не парковать поток в тот момент, когда вскоре будет готова новая горутина к выполнению.

```go
Ограничение планировщика Go: нет информации о будущем

Время T0:
P1.runq = [], P2.runq = [G1], Global runq = []
M1 исполняет G0

Планировщик видит только текущие очереди.

Проблема: планировщик не знает, что G2 вскоре готова к выполнению
и может преждевременно парковать поток M1

       +-----+
P1 ->  | --- |  <-- пусто
       +-----+
P2 ->  | G1  |  <-- готова
       +-----+
M1 ->  | G0  |  <-- исполняется
       +-----+

Если бы была информация о будущем:
  M1 мог бы не парковаться, а дождаться G2

```

---
## Три отклоненных подхода, которые показали бы низкую эффективность:

1.  Централизация состояния планировщика. 
>Этот подход ограничил бы масштабируемость системы, тк привел бы к узкому месту при доступе к общим данным.

2.  Прямая передача горутины (Direct goroutine handoff).
> При таком подходе, когда создается новая готовая горутина и имеется свободный процессор (P), планировщик сам «распарковывает» поток и напрямую передает ему как саму горутину, так и процессор. 
> Это бы привело к «дрожанию» состояния потоков (thread state trashinig) : Поток, запустивший горутину, может мгновенно остаться без работы, и его придется парковать. 
> Кроме того, это разрушает локальность вычислений (тк зависимые горутины желательно выполнять на одном и том же потоке) и вносит дополнительную задержку.

3.  Распарковка дополнительного потока при готовности новой горутины без прямой задачи.
> В этом случае при появлении новой горутины и наличии свободного процессора (P) просто активируется новый поток без передачи горутины напрямую.
> Такой подход приводит к чрезмерным операциям парковки и распарковки потоков, поскольку «дополнительные» потоки быстро обнаруживают остутствие работы и снова паркуются.

--- 
## Текущий подход: 

Этот подход применяется к трем основным источникам потенциальной работы:
1. Подготовке горутины к выполнению (readying a goroutine),
2. Созданию или изменению таймеров (_new/modified-earlier timers_), 
3. Задачам сборщика мусора с пониженным приоритетом (_idle-priority GC_).

При добавлении новой работы (см функцию `{go} wakep()` на proc.go 3154 str) планировщик «распарковывает» дополнительный поток при выполнении следующих условий: 

1. Имеется хотя бы один неактивный процессор (idle P), 
2. Нет потоков, находящихся в состоянии «вращения» (spinning).

Рабочий поток называется **spinning**, если у него закончилась локальная работа, и он не нашел работу ни в глобальной очереди выполнения, ни через сетевой поллер ([netpoller](netpoller)).

Состояние «вращения» фиксируется в полях **m.spinning** и **sched.nmspinning**. Потоки, распаркованные этим способом, также считаются **spinning**, тк подача горутины напрямую (handoff) не выполняется - изначально у них нет работы.

Потоки в состоянии «вращения» активно ищут работу в локальных очередях выполнения (per-P run queues), в кучах таймеров или в заданиях от сборщика мусора (GC).

Если поток находит работу, он снимает с себя флаг **spinning** и приступает к выполнению.
Если работу найти не удается, поток также снимает с себя флаг **spinning**, но после этого паркуется.

---
Если существует хотя бы один поток в состоянии «вращения» (spinning thread, т.е. `{go} sched.nmspinning > 1`), то при добавлении новой работы **планировщик не распарковывает** дополнительные потоки.

Чтобы компенсировать это поведение, если последний поток в состоянии «вращения» находит себе работу и переходит в **не вращающееся** состояние (non-spinning state), он обязан распарковать новый поток, который начнет вращаться (spinning thread).

Такой подход позволяет сгладить неоправданные всплески активности, связанные с массовым распарковыванием потоков, и при этом гарантирует эффективное использование всей доступной CPU-параллельности (то есть, все доступные процессоры будут задействованы, когда это действительно нужно).

---
**Основная сложность** реализации заключается в том, что при переходе из состояния **spinning** в **non-spinning** нужно быть **крайне осторожным**, чтобы избежать **состояния гонки** (race condition). 

Такой переход может совпасть по времени с моментом, когда в систему поступает новая работа. 
В этой ситуации либо поток, который завершает вращение, либо тот, кто добавляет новую работу, должен распарковать новый рабочий поток.

Если оба этих участника одновременно «пропустят» необходимость распарковки, может возникнуть состояние **частичной недоиспользованности CPU** - ситуация, когда часть процессоров остается без работы, хотя работа в системе есть.

---
## Общий шаблон (паттерн) для добавления работы (submission) выглядит так:

1.  Поместить задачу в **локальную** или **глобальную очередь выполнения** (run queue), кучу таймеров (timer heap) или структуры данных GC (например, очередь для фоновой обработки мусора).
2.  Выполнить **барьер памяти типа `{go} #StoreLoad`** - он гарантирует корректный порядок видимости операций между потоками (то есть, что все записи, сделанные до этого момента, будут видны другим потокам до последующих чтений). 
3.  Проверить значение `{go} sched.nmspinning` - счетчик текущих «вращающихся» потоков (spinning threads).

---
## Общий шаблон (паттерн) для перехода из состояния «вращающийся» → «не вращающийся» (spinning → non-spinning) : 

1.  Уменьшить счетчик `{go} sched.nmspinning` (декрементировать счетчик).
2.  Выполнить **барьер памяти типа `{go} #StoreLoad`**, чтобы гарантировать корректную видимость изменений другим потокам.
3. Проверить все **локальные очереди задач (per-P run queues)** и **очередь GC**, чтобы убедиться, что **новая работа действительно не появилась**.

---
Важно, что вся эта сложная синхронизация **не применяется к глобальной очереди задач (global run queue)**, поскольку при добавлении работы в глобальную очередь планировщик **не жертвует точностью ради оптимизации** - он всегда может позволить себе «избыточное» пробуждение потока.

То, как ведут себя различные источники работы, различается, однако это **не влияет на общий механизм синхронизации**: 

- **Готовая горутина (Ready goroutine)**: 

> Очевидный источник работы - горутина уже находится в состоянии готовности и в конечном итоге должна быть выполнена на каком-то потоке.

- **Новый или измененный ранее таймер (New/Modified-earlier timer)**:

> Текущая реализация таймеров (см `{go} time.go`) 
> использует сетевой поллер (netpoll)
> в потоке без активной работы, 
> для ожидания ближайшего срабатывания таймера. 
> 
> Если нет потока, ожидающего таймер, 
> необходимо **запустить новый «вращающийся» поток 
> (spinning thread)**.

- **Фоновый GC с низким приоритетом (Idle-priority GC)**: 

> Сборщик мусора (GC) пробуждает **оставленный бездействующий поток**,
чтобы тот поучаствовал в **выполнении фоновой работы GC**.

> Примечание: на данный момент эта функция **отключена**, см. golang.org/issue/19112.  
Также см. golang.org/issue/44313,  
так как в будущем планируется **распространить это поведение на всех рабочих потоков GC**.

---
## Описание работы main горутины:
[main goroutine](main%20goroutine)

---
